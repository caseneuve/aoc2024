#+title: Advent of Code 2024: Notes


* Day 1

** Part 1

I'm particularly fond of using threading macros in Clojure, as they make it
easy to follow and express input transformations step by step. It's
interesting how this preference can sometimes lead to tunnel vision,
preventing me from noticing simpler solutions.

For example, consider this implementation:

#+begin_src clojure
  (->> lists
       (map sort)
       (apply map list)
       (reduce (fn [s p] (+ s (abs (apply - p)))) 0))
#+end_src

Here, there's a transposing step to create a list of pairs from two lists
(=(apply map list)=), but it's somewhat redundant since the operations in
=reduce= can be performed directly without transposing:

#+begin_src clojure
  (->> lists
       (map sort)
       (apply #(mapv (comp abs -) %1 %2))
       (apply +))
#+end_src

Finally, stepping away from the threading mindset and flipping the logic upside down reduces this to a one-liner:

#+begin_src clojure
(reduce + (mapv (comp abs -) (map sort lists)))
#+end_src

Now -- I like it because it's consise and I already know the logic, but is
it more readable?


** Part 2

I completely forgot about =frequencies= -- honestly, I was surprised such an obvious utility hadn't already been implemented...  Naturally, this:

#+begin_src clojure
(->> right (reduce (fn [m e] (update m e (fnil inc 0))) {}))
#+end_src

can be replaced with the much simpler:

#+begin_src clojure
(frequencies right)
#+end_src

and then redundant threading becomes:

#+begin_src clojure
(reduce (fn [s n] (+ (* n (fqs n 0)) s)) 0 left)
#+end_src

Initial =0= in =reduce= can be eliminated by using transducer that maps
over the first list:

#+begin_src clojure
(transduce (map #(abs (* % (fqs % 0)))) + left)
#+end_src

Once again, I like the transducer version when I see it -- no need for a
redundant initial step, and no need for an explicit fn declaration. That
said, "transductions" still bend my mind a bit!

P.S.  I'm still glad I wrote my version of =frequencies=.  It gave me the
opportunity to discover =fnil= which combined with =update=, provides
functionality similar to Python's =defaultdict=: =(update MAP key (fnil inc 0))=.

* Day 3

In my first approach, I used a straightforward loop:

#+begin_src clojure
  (loop [[op & xs] ops, enabled true, sum 0]
    (if (nil? op) sum
        (condp = op
          "do()"    (recur xs true sum)
          "don't()" (recur xs false sum)
                    (recur xs enabled (cond-> sum (or enabled (= part 1)) (+ (mul op)))))))
#+end_src

Here, =ops= is a list of all occurrences of "muls", "dos", and
"don'ts". It's still quite verbose with three =recur= calls. The =mul=
function computes the product of integers extracted from the matching
strings.

Wanting a more concise solution, I initially tried to write smarter
regexes.  However, this quickly led to the classic "now you have two
problems" scenario.  As it turns out, the simpler solution wasn't
about designing a better regex to catch what I needed but to /remove/
irrelevant parts of the input using one.

So the trick fo part 2 is =(str/replace s #"(?s)don't\(\).*?(do\(\)|\Z)" "")=.

Hereâ€™s how it works:

- =(?s)= enables /dot-matches-all/ mode, allowing =.= to match any character, including newlines (=\n=).
- =.*?= matches zero or more of any character, /non-greedily/.
- =(do\(\)|\Z)= matches =do()= or /the end of input/ (=\Z=).

Using this cleanup step, the revised solution looks like this:

#+begin_src clojure
(defn clear-donts [s] (str/replace s #"(?s)don't\(\).*?(do\(\)|\Z)" ""))

(defn solve [input part]
  (let [ops (re-seq #"mul\(\d+,\d+\)" (cond-> input (= part 2) clear-donts))
        mul #(apply * (map read-string (re-seq #"\d+" %)))]
    (->> ops (map mul) (apply +))))
#+end_src
